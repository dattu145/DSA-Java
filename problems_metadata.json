{
  "Algorithms/Sorting/BubbleSort.java": {
    "intuition": "Repeatedly push the largest element to the end by comparing adjacent elements.",
    "technique": "Basic Sorting",
    "timeComplexity": "O(N^2)",
    "spaceComplexity": "O(1)"
  },
  "Basics/binaryToDecimal.java": {
    "intuition": "Convert each binary digit to its decimal weight using powers of 2.",
    "technique": "Math / Bit Manipulation",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Basics/decimalToBinary.java": {
    "intuition": "Divide by 2 repeatedly and collect remainders to form binary representation.",
    "technique": "Math / Bit Manipulation",
    "timeComplexity": "O(logN)",
    "spaceComplexity": "O(1)"
  },
  "Basics/fundamentals/Armstrong.java": {
    "intuition": "Check if the sum of each digit raised to its count equals the number.",
    "technique": "Number Theory",
    "timeComplexity": "O(D)",
    "spaceComplexity": "O(1)"
  },
  "Basics/fundamentals/FibonacciNumber.java": {
    "intuition": "Build Fibonacci numbers iteratively using previous two values.",
    "technique": "DP / Recurrence",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Basics/fundamentals/Palindrome.java": {
    "intuition": "Reverse the digits and compare with the original.",
    "technique": "Two-Pointer / Math",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Basics/fundamentals/PrimeNumberCheck.java": {
    "intuition": "Check divisibility until sqrt(n).",
    "technique": "Number Theory",
    "timeComplexity": "O(sqrt(N))",
    "spaceComplexity": "O(1)"
  },
  "Easy/MajorityElement.java": {
    "intuition": "Use Boyer–Moore voting to find the element that occurs more than n/2 times.",
    "technique": "Greedy / Voting Algorithm",
    "timeComplexity": "O(N^2)",
    "spaceComplexity": "O(1)"
  },
  "Easy/RemoveElement.java": {
    "intuition": "Use two pointers to overwrite unwanted values.",
    "technique": "Two Pointers",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Easy/RepeatingAndMissingValues.java": {
    "intuition": "Use extra XOR/Math to detect repeated and missing values.",
    "technique": "Math / Hashing",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Easy/TwoPointers/Arrays/BestTimeToBuyAndSellStock.java": {
    "intuition": "Track the lowest buy price and calculate max profit greedily.",
    "technique": "Two Pointers",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Easy/TwoPointers/Arrays/MergeSortedArray.java": {
    "intuition": "Merge from the back to avoid overwriting values.",
    "technique": "Two Pointers / Merge Technique",
    "timeComplexity": "O(N+M)",
    "spaceComplexity": "O(1)"
  },
  "Easy/TwoPointers/Arrays/MoveZeros.java": {
    "intuition": "If fast != 0, swap with slow and increment slow",
    "technique": "Two Pointers",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Easy/TwoPointers/Arrays/RemoveDuplicatesFromSortedArrays.java": {
    "intuition": "If slow != fast; slow++ and value of slow equals value of fast.",
    "technique": "Two Pointers",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Easy/TwoPointers/Arrays/SquaresOfaSortedArray.java": {
    "intuition": "Square from both ends and place the largest in output from end.",
    "technique": "Two Pointers",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(N)"
  },
  "Easy/TwoPointers/Arrays/TwoSum_II.java": {
    "intuition": "Move left or right pointer based on sum comparison.",
    "technique": "Two Pointers",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Easy/TwoPointers/Strings/ReverseAString.java": {
    "intuition": "Swap characters from both ends until pointers meet.",
    "technique": "Two Pointers",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Easy/TwoPointers/Strings/validPalindrome.java": {
    "intuition": "Use two pointers while skipping non-alphanumeric characters.",
    "technique": "Two Pointers",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "JCF/ArrayLists.java": {
    "intuition": "Demonstration of dynamic array operations.",
    "technique": "Java Collections Framework",
    "timeComplexity": "Varies",
    "spaceComplexity": "Varies"
  },
  "JCF/HashMaps.java": {
    "intuition": "Shows how key-value hashing works in Java.",
    "technique": "Hash Map / Hashing",
    "timeComplexity": "Average O(1)",
    "spaceComplexity": "O(N)"
  },
  "Medium/TwoPointers/Arrays/ContainerWithMaxWater.java": {
    "intuition": "Shrink the pointer of the shorter line to maximize area.",
    "technique": "Two Pointers",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Medium/TwoPointers/Arrays/FourSum.java": {
    "intuition": "Fix two pointers and use inner two-pointer technique for remaining pair.",
    "technique": "Two Pointers + Sorting",
    "timeComplexity": "O(N^3)",
    "spaceComplexity": "O(1)"
  },
  "Medium/TwoPointers/Arrays/SortColors.java": {
    "intuition": "Use Dutch National Flag algorithm to partition colors.",
    "technique": "Three-Pointer / Partitioning",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Medium/TwoPointers/Arrays/ThreeSum.java": {
    "intuition": "Sort the array and use two pointers for each fixed value.",
    "technique": "Two Pointers + Sorting",
    "timeComplexity": "O(N^2)",
    "spaceComplexity": "O(1)"
  },
  "Medium/TwoPointers/RomanToInteger.java": {
    "intuition": "Scan from left to right and subtract for special cases.",
    "technique": "Hash Map / Pattern Matching",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Medium/SlidingWindow/Arrays/MinimumSizeSubarraySum.java": {
    "intuition": "Use a sliding window because all numbers are positive. Expand the window with the right pointer to increase sum, and shrink from the left to find the smallest valid window.",
    "technique": "Sliding Window (Two Pointers)",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Medium/SlidingWindow/Strings/PermutationInStrings.java": {
    "intuition": "A permutation has the same character counts regardless of order. Use a fixed-size sliding window of length s1 over s2 and compare character frequencies to detect when a window matches s1.",
    "technique": "Sliding Window with Frequency Array",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Easy/SlidingWindow/Arrays/DefuseABomb.java": {
    "intuition": "Each element in the output depends on the sum of the next k or previous k elements in a circular array. Use a sliding window of size k to compute sums efficiently without recomputing each time.",
    "technique": "Sliding Window / Circular Array Handling",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(N) // for the output array"
  },
  "Easy/SlidingWindow/Arrays/MaximumAverageSubArrayI.java": {
    "intuition": "To find the maximum average of a subarray of fixed length k, maintain a sliding window sum of size k and update the maximum sum as the window moves.",
    "technique": "Fixed-size Sliding Window / Prefix Sum",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Medium/SlidingWindow/Arrays/GrumpyBookstoreOwner.java": {
    "intuition": "Customers are satisfied when the owner is not grumpy. Use a sliding window of size X to flip grumpy minutes into satisfied ones, and maximize the additional satisfied customers.",
    "technique": "Sliding Window / Fixed-size Window / Prefix Sum Concept",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Medium/SlidingWindow/Strings/FindAllAnagramsInAString.java": {
    "intuition": "An anagram has the same character counts as the target string. Slide a window of target string length over the main string, and track character frequencies to find all starting indices that match.",
    "technique": "Sliding Window with Frequency Map / Hash Map",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1) // if we use fixed alphabet size array"
  },
  "Medium/SlidingWindow/Strings/LongestSubstringWithoutRepeatingCharacters.java": {
    "intuition": "Maintain a window with all unique characters. Expand the window by moving the right pointer, and when a duplicate is found, shrink the window from the left until all characters are unique again. Track the maximum window size during the process.",
    "technique": "Sliding Window with HashSet / Frequency Array",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1) // O(128) for ASCII characters, treated as constant"
  },
  "Easy/SlidingWindow/Arrays/DietPlanPerformance.java": {
      "intuition": "Calculate the sum of the first window of size k. Then slide the window across the array by removing the leftmost element and adding the new rightmost element. For each window sum, adjust the score based on whether it falls below, within, or above the given thresholds.",
      "technique": "Fixed Size Sliding Window",
      "timeComplexity": "O(N)",
      "spaceComplexity": "O(1)"
  },
    "Medium/SlidingWindow/Arrays/MaxConsecutiveOnesIII.java": {
    "intuition": "right expands; zero++ → if zero > k, left++ until valid.",
    "technique": "Variable Size Sliding Window (At most K zeros)",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
    "Easy/SlidingWindow/Arrays/MaxConsecutiveOnes.java": {
    "intuition": "Keep extending; on zero → left = right + 1; maxCount = Math.max(maxCount, right - left + 1)",
    "technique": "Sliding Window with Hard Reset",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
   "Medium/SlidingWindow/Arrays/LongestSubstringAfterDeletingOneElement.java": {
    "intuition": "Expand window; allow at most one zero. If zeros > 1, shrink from left. Track max window length and subtract 1 for the deleted element.",
    "technique": "Variable-size Sliding Window (At most 1 invalid element)",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  },
  "Easy/SlidingWindow/Arrays/ContainDuplicatesII.java": {
    "intuition": "Maintain a window of size k using a HashSet. If current element already exists in set, duplicate found within range.",
    "technique": "Fixed-size Sliding Window with HashSet",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(K)"
  },
  "Easy/SlidingWindow/Strings/FindKBeautyOfaNumber.java": {
    "intuition": "Slide a fixed window of length k over the string number. Convert substring to int and count if it divides the original number.",
    "technique": "Fixed-size Sliding Window using String Substring",
    "timeComplexity": "O(N)",
    "spaceComplexity": "O(1)"
  }
}